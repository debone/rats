import {
  Assets,
  extensions,
  ExtensionType,
  Resolver,
  resolveTextureUrl,
  type AssetsManifest,
  type ResolveURLParser,
  type UnresolvedAsset,
} from 'pixi.js';

export const resolveJsonUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value: string): boolean => Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),
  parse: resolveTextureUrl.parse,
} as ResolveURLParser;

extensions.add(resolveJsonUrl);

/** List of assets grouped in bundles, for dynamic loading */
let assetsManifest: AssetsManifest = { bundles: [] };

/** Store bundles already loaded */
// const loadedBundles: string[] = [];

/** Load the assets json manifest generated by assetpack */
async function fetchAssetsManifest(url: string) {
  const response = await fetch(url);
  const manifest = await response.json();
  if (!manifest.bundles) {
    throw new Error('[Assets] Invalid assets manifest');
  }
  return manifest;
}

/** Initialise and start background loading of all assets */
export async function initAssets() {
  // Load the assets json manifest generated by assetpack
  assetsManifest = await fetchAssetsManifest('assets/assets-manifest.json');

  // Init PixiJS assets with this asset manifest
  await Assets.init({ manifest: assetsManifest as AssetsManifest, basePath: 'assets' });

  // Load assets for the load screen
  await Assets.loadBundle(['preload', 'default']);

  // List all existing bundles names
  const allBundles = assetsManifest.bundles.map((item: any) => item.name);

  // Start up background loading of all bundles
  Assets.backgroundLoadBundle(allBundles);
}

/**
 * Check to see if a bundle has loaded
 * @param bundle - The unique id of the bundle
 * @returns Whether or not the bundle has been loaded
 */
export function isBundleLoaded(bundle: string) {
  const bundleManifest = assetsManifest.bundles.find((b: any) => b.name === bundle);

  if (!bundleManifest) {
    return false;
  }

  for (const asset of bundleManifest.assets as UnresolvedAsset[]) {
    if (!Assets.cache.has(asset.alias as string)) {
      return false;
    }
  }

  return true;
}

export function areBundlesLoaded(bundles: string[]) {
  for (const name of bundles) {
    if (!isBundleLoaded(name)) {
      return false;
    }
  }

  return true;
}

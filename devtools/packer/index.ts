import { type Asset, type AssetPipe, checkExt, createNewAssetAt, swapExt } from '@assetpack/core';
import sharp from 'sharp';

import Aseprite from './lib/ase-parser.ts';
import { extractSprites } from './processors/aseprite.ts';
import { Atlas } from './processors/atlas.ts';

/**
 * Generate TypeScript content for atlas config
 */
export function generateTypescriptContent(atlasConfig: Record<string, any>, baseName: string): string {
  const configName = toPascalCase(baseName) + 'Frames';

  let content = `// Auto-generated TypeScript file for ${baseName} multiatlas frames\n`;
  content += `// Do not edit this file manually - it will be overwritten\n\n`;

  content += `export const ${configName} = {\n`;

  for (const [frameName, frame] of Object.entries(atlasConfig)) {
    const safeKey = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(frameName) ? frameName : JSON.stringify(frameName);
    content += `  ${safeKey}: {\n`;
    content += `    x: ${frame.x},\n`;
    content += `    y: ${frame.y},\n`;
    content += `    w: ${frame.w},\n`;
    content += `    h: ${frame.h},\n`;
    content += `  },\n`;
  }

  content += `} as const;\n\n`;

  content += `export const ${configName}Names = {
    ${Object.keys(atlasConfig)
      .map((frameName) => `"${frameName}": "${frameName}"`)
      .join(',\n')}
  } as const;\n\n`;

  // Add type exports for better TypeScript support
  content += `export type ${configName}Keys = keyof typeof ${configName};\n`;
  content += `export type ${configName}Frame = (typeof ${configName})[${configName}Keys];\n`;

  return content;
}

/**
 * Convert kebab-case or other formats to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

interface PackerOptions {
  resolutionOptions?: {
    template?: string;
    resolutions?: Record<string, number>;
  };
}

export type PackerTags = 'tps' | 'nomip';

export function packer(_options: PackerOptions = {}): AssetPipe<PackerOptions, PackerTags> {
  return {
    name: 'packer',
    defaultOptions: {
      resolutionOptions: {
        template: '@%%x',
        resolutions: { default: 1, low: 0.5 },
        ..._options.resolutionOptions,
      },
    },
    tags: {
      tps: 'tps',
      nomip: 'nomip',
    },
    test: (asset) => checkExt(asset.path, '.aseprite'),
    transform: async (asset, options) => {
      return processFile(asset, options);
    },
  };
}

/**
 * Create a name with resolution suffix (matching texturePacker format)
 */
function createName(name: string, scale: number, format: string): string {
  const scaleLabel = scale !== 1 ? `@${scale}x` : '';
  return `${name}${scaleLabel}.${format}`;
}

/**
 * Parse Aseprite file and extract sprites
 */
async function parseAsepriteFile(asset: Asset) {
  const asepriteFile = new Aseprite(asset.buffer, asset.filename);
  console.log(`Parsing Aseprite data...`);
  asepriteFile.parse();

  console.log(`Aseprite file ${asset.filename} parsed successfully`);
  console.log(`Dimensions: ${asepriteFile.width}x${asepriteFile.height}, Layers: ${asepriteFile.layers.length}`);

  // Get spritesheet size from metadata and base name for composite sprite
  const spritesheetSize = asset.metaData?.ss as number | undefined;
  // Strip metadata tags like {ss=32} from the base name
  const rawBaseName = swapExt(asset.filename, '').split('/').pop() || 'sprite';
  const baseName = rawBaseName.replace(/\{[^}]*\}/g, '');

  const { sprites } = await extractSprites(asepriteFile, {
    spritesheetSize,
    baseName,
  });

  if (sprites.length === 0) {
    throw new Error('No valid sprites found in the Aseprite file');
  }

  const contentLayers = sprites.filter((s) => !s.name.endsWith('-slices') && !s.name.endsWith('_spritesheet'));
  const sliceLayers = sprites.filter((s) => s.name.endsWith('-slices'));
  const spritesheetLayers = sprites.filter((s) => s.name.endsWith('_spritesheet'));

  console.log(`Found ${sprites.length} total sprites:`);
  console.log(`- ${contentLayers.length} content layers`);
  console.log(`- ${sliceLayers.length} slice layers`);
  if (spritesheetLayers.length > 0) {
    console.log(`- ${spritesheetLayers.length} spritesheet composite frames (ss=${spritesheetSize})`);
  }

  return sprites;
}

/**
 * Scale atlas buffer to target resolution
 */
async function scaleAtlasBuffer(buffer: Buffer, scale: number): Promise<Buffer> {
  if (scale === 1) return buffer;

  const metadata = await sharp(buffer).metadata();
  return sharp(buffer)
    .resize(Math.round(metadata.width! * scale), Math.round(metadata.height! * scale), { kernel: 'lanczos3' })
    .png()
    .toBuffer();
}

/**
 * Create PNG and JSON assets for a specific resolution
 */
function createResolutionAssets(
  asset: Asset,
  baseName: string,
  scaledBuffer: Buffer,
  atlas: Atlas,
  resolution: number,
): [Asset, Asset] {
  // Create PNG asset
  const pngName = createName(baseName, resolution, 'png');
  const pngAsset = createNewAssetAt(asset, pngName);
  pngAsset.buffer = scaledBuffer;
  pngAsset.metaData.mIgnore = true; // Don't process this image again
  pngAsset.metaData.nomip = true; // Already mipmapped

  // Create JSON asset (base .json, texturePackerCompress will create format variants)
  const jsonName = createName(baseName, resolution, 'json');
  const jsonAsset = createNewAssetAt(asset, jsonName);

  // Generate metadata with image reference
  const pngBasename = pngName.split('/').pop() || pngName;
  const metadata = atlas.metadata(pngBasename);
  metadata.meta.scale = resolution;

  jsonAsset.buffer = Buffer.from(JSON.stringify(metadata, null, 2));
  jsonAsset.metaData.tps = true; // Mark for texturePackerCompress

  return [pngAsset, jsonAsset];
}

/**
 * Process Aseprite file and generate atlas with multiple resolutions
 */
async function processFile(asset: Asset, options: PackerOptions): Promise<Asset[]> {
  // Parse Aseprite and extract sprites
  const sprites = await parseAsepriteFile(asset);

  // Build atlas
  console.log(`Adding sprites to atlas...`);
  const atlas = new Atlas();
  atlas.addSprites(sprites);

  console.log(`Generating atlas...`);
  const atlasBuffer = await atlas.buffer();

  // Generate assets for each resolution
  const { resolutions } = options.resolutionOptions!;
  const largestResolution = Math.max(...Object.values(resolutions!));
  const baseName = swapExt(asset.filename, '');
  const assets: Asset[] = [];

  for (const [_resKey, resolution] of Object.entries(resolutions!)) {
    const scale = resolution / largestResolution;
    console.log(`Generating ${resolution}x assets (scale: ${scale})...`);

    const scaledBuffer = await scaleAtlasBuffer(atlasBuffer, scale);
    const [pngAsset, jsonAsset] = createResolutionAssets(asset, baseName, scaledBuffer, atlas, resolution);

    assets.push(pngAsset, jsonAsset);
  }

  return assets;
}

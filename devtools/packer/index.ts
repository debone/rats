import * as fs from 'fs';
import * as path from 'path';

import { Asset, AssetPipe, checkExt, createNewAssetAt, swapExt } from '@assetpack/core';

import Aseprite from './lib/ase-parser.ts';

import { extractSprites } from './processors/aseprite.ts';
import { Atlas } from './processors/atlas.ts';
import type { PackerOptions } from './types.ts';

/**
 * Generate TypeScript content for atlas config
 */
function generateTypescriptContent(atlasConfig: Record<string, any>, baseName: string): string {
  const configName = toPascalCase(baseName) + 'Frames';

  let content = `// Auto-generated TypeScript file for ${baseName} multiatlas frames\n`;
  content += `// Do not edit this file manually - it will be overwritten\n\n`;

  content += `export const ${configName} = {\n`;

  for (const [frameName, frame] of Object.entries(atlasConfig)) {
    const safeKey = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(frameName) ? frameName : JSON.stringify(frameName);
    content += `  ${safeKey}: {\n`;
    content += `    x: ${frame.x},\n`;
    content += `    y: ${frame.y},\n`;
    content += `    w: ${frame.w},\n`;
    content += `    h: ${frame.h},\n`;
    content += `  },\n`;
  }

  content += `} as const;\n\n`;

  content += `export const ${configName}Names = {
    ${Object.keys(atlasConfig)
      .map((frameName) => `"${frameName}": "${frameName}"`)
      .join(',\n')}
  } as const;\n\n`;

  // Add type exports for better TypeScript support
  content += `export type ${configName}Keys = keyof typeof ${configName};\n`;
  content += `export type ${configName}Frame = (typeof ${configName})[${configName}Keys];\n`;

  return content;
}

/**
 * Convert kebab-case or other formats to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

interface PackerOptions {}

export function packer(): AssetPipe<PackerOptions> {
  return {
    name: 'packer',
    defaultOptions: {},
    test: (asset) => checkExt(asset.path, '.aseprite'),
    transform: async (asset) => {
      //const command = `${asepritePath} -b ${asset.path} -o ${ass}`;
      const oldFilename = asset.filename;
      const newFilename = swapExt(oldFilename, '.jsond');
      return processFile(asset);
    },
  };
}

const debug = false;

async function processFile(asset: Asset): Promise<Asset[]> {
  const asepriteFile = new Aseprite(asset.buffer, asset.filename);
  console.log(`Parsing Aseprite data...`);
  asepriteFile.parse();

  console.log(`Aseprite file ${asset.filename} parsed successfully`);
  console.log(`Dimensions: ${asepriteFile.width}x${asepriteFile.height}, Layers: ${asepriteFile.layers.length}`);

  if (debug) {
    console.log(`Debug information:`);
    console.log(` - Number of frames: ${asepriteFile.frames?.length || 0}`);
    console.log(` - Number of layers: ${asepriteFile.layers?.length || 0}`);
    console.log(` - Layer names: ${(asepriteFile.layers || []).map((l) => l.name || 'unnamed').join(', ')}`);

    // Only log header properties if they exist (optional chaining)
    if (typeof asepriteFile === 'object') {
      console.log(` - Width: ${asepriteFile.width}`);
      console.log(` - Height: ${asepriteFile.height}`);

      // Additional header info if available
      const header = (asepriteFile as any).header;
      if (header) {
        console.log(` - Aseprite version: ${header.version || 'unknown'}`);
        console.log(` - Color depth: ${header.colorDepth || 'unknown'} bits per pixel`);
        console.log(` - Transparent color index: ${header.transparentColorIndex || 'none'}`);
      }
    }
  }

  // Extract sprites from Aseprite file
  console.log(`Extracting sprites...`);
  const { sprites, atlasConfig } = await extractSprites(asepriteFile);
  if (sprites.length === 0) {
    throw new Error('No valid sprites found in the Aseprite file');
  }

  // Count regular layers vs slice layers
  const contentLayers = sprites.filter((s) => !s.name.endsWith('-slices'));
  const sliceLayers = sprites.filter((s) => s.name.endsWith('-slices'));

  console.log(`Found ${sprites.length} total layers:`);
  console.log(`- ${contentLayers.length} content layers`);
  console.log(`- ${sliceLayers.length} slice layers`);

  if (debug) {
    for (const sprite of sprites) {
      console.log(
        `  - Sprite "${sprite.name}": ${sprite.width}x${sprite.height}, data size: ${sprite.data.length} bytes`,
      );
    }
  }

  // Process the sprites
  console.log(`Adding sprites to atlas...`);
  const atlas = new Atlas();
  atlas.addSprites(sprites);

  // Generate individual image files for each layer
  console.log(`Generating image files...`);
  //  const atlasBasePath = path.join(absoluteOutput, `${baseName}.png`);
  const atlasBuffer = await atlas.buffer();

  const atlasImageFilename = swapExt(asset.filename, '.png');
  const atlasImageAsset = createNewAssetAt(asset, atlasImageFilename);
  atlasImageAsset.buffer = atlasBuffer;

  const atlasJsonFilename = swapExt(asset.filename, '.png.json');
  const atlasJsonAsset = createNewAssetAt(asset, atlasJsonFilename);
  atlasJsonAsset.buffer = Buffer.from(JSON.stringify(atlas.metadata(), null, 2));

  return [atlasImageAsset, atlasJsonAsset];
}

/*
async function processAsepriteFile(options: PackerOptions): Promise<void> {


    // Generate and save metadata in MultiAtlas format
    console.log(`Generating metadata...`);
    const metadata = atlas.generateMetadata(imagePaths);

    const metadataPath = path.join(absoluteOutput, `${baseName}.json`);
    await fs.promises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));

    // Generate TypeScript file for atlas config in src/assets
    const srcAssetsDir = path.resolve('src/assets');
    await fs.promises.mkdir(srcAssetsDir, { recursive: true });

    const typescriptPath = path.join(srcAssetsDir, `${baseName}-frames.ts`);
    const typescriptContent = generateTypescriptContent(atlasConfig, baseName);
    await fs.promises.writeFile(typescriptPath, typescriptContent);

    // Get the actual total frames (excluding slice layers)
    const totalFrames = metadata.textures.reduce((sum, texture) => sum + texture.frames.length, 0);

    console.log(`MultiAtlas metadata saved to ${metadataPath}`);
    console.log(`TypeScript frames file saved to ${typescriptPath}`);
    console.log(`Total frames in metadata: ${totalFrames}`);
  } catch (error) {
    console.error('Error processing Aseprite file:', error);

    if (error instanceof Error) {
      console.error(`Error message: ${error.message}`);
      console.error(`Error stack: ${error.stack}`);
    }

    if (options.debug) {
      console.error('Full error details:', JSON.stringify(error, null, 2));
    }

    throw error;
  }
}
*/

import * as fs from 'fs';
import * as path from 'path';

interface ManifestAsset {
  alias: string[];
  src: string[];
  data: {
    tags: Record<string, any>;
  };
}

interface ManifestBundle {
  name: string;
  assets: ManifestAsset[];
}

interface AssetsManifest {
  bundles: ManifestBundle[];
}

/**
 * Generate TypeScript definitions for the assets manifest
 */
export function generateManifestTypes(manifestPath: string, outputPath: string): void {
  try {
    // Read the manifest file
    const manifestContent = fs.readFileSync(manifestPath, 'utf-8');
    const manifest: AssetsManifest = JSON.parse(manifestContent);

    // Collect all asset aliases
    const assetAliases = new Set<string>();
    const bundleNames = new Set<string>();

    for (const bundle of manifest.bundles) {
      bundleNames.add(bundle.name);
      for (const asset of bundle.assets) {
        for (const alias of asset.alias) {
          assetAliases.add(alias);
        }
      }
    }

    // Generate TypeScript content
    let content = `// Auto-generated TypeScript file for assets manifest\n`;
    content += `// Do not edit this file manually - it will be overwritten\n\n`;

    // Asset aliases type
    content += `export type AssetAlias =\n`;
    content += Array.from(assetAliases)
      .map((alias) => `  | "${alias}"`)
      .join('\n');
    content += `;\n\n`;

    // Bundle names type
    content += `export type BundleName =\n`;
    content += Array.from(bundleNames)
      .map((name) => `  | "${name}"`)
      .join('\n');
    content += `;\n\n`;

    // Asset aliases constant
    content += `export const ASSETS = {\n`;
    const seenKeys = new Set<string>();
    for (const alias of Array.from(assetAliases).sort()) {
      // Remove common extensions from the key, then sanitize
      const withoutExt = alias.replace(/\.(aseprite|png|jpg|jpeg|webp|svg|json)$/i, '');
      // Replace slashes, dots, and dashes with underscores, prefix numbers with underscore
      let safeKey = withoutExt.replace(/[\/.-]/g, '_').replace(/^(\d)/, '_$1');

      // Handle collisions by appending a number
      let finalKey = safeKey;
      let counter = 1;
      while (seenKeys.has(finalKey)) {
        finalKey = `${safeKey}_${counter}`;
        counter++;
      }
      seenKeys.add(finalKey);

      content += `  ${finalKey}: "${alias}" as const,\n`;
    }
    content += `} as const;\n\n`;

    // Bundle names constant
    content += `export const BUNDLES = {\n`;
    for (const name of Array.from(bundleNames).sort()) {
      const safeKey = name.toUpperCase().replace(/[.-]/g, '_');
      content += `  ${safeKey}: "${name}" as const,\n`;
    }
    content += `} as const;\n`;

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write the TypeScript file
    fs.writeFileSync(outputPath, content);
    console.log(`Generated manifest types at ${outputPath}`);
  } catch (error) {
    console.error('Failed to generate manifest types:', error);
  }
}

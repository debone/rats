import * as fs from 'fs';
import * as path from 'path';

interface AtlasFrameData {
  [atlasName: string]: {
    [frameName: string]: {
      x: number;
      y: number;
      w: number;
      h: number;
    };
  };
}

/**
 * Sanitize atlas name to match ASSETS key format
 * Same logic as manifest generation: replace slashes, dots, and dashes with underscores
 */
function sanitizeAtlasKey(atlasName: string): string {
  return atlasName.replace(/[\/.-]/g, '_').replace(/^(\d)/, '_$1');
}

/**
 * Generate TypeScript content for all atlas frames
 * Creates both frame names (for texture access) and frame data (for position/size)
 */
function generateFramesNamespace(atlasData: AtlasFrameData): string {
  let content = `// Auto-generated TypeScript file for all atlas frames\n`;
  content += `// Do not edit this file manually - it will be overwritten\n\n`;

  // Generate FRAMES with frame name strings
  content += `/** Frame names for accessing textures */\n`;
  content += `export const FRAMES = {\n`;

  for (const [atlasName, frames] of Object.entries(atlasData)) {
    const safeAtlasKey = sanitizeAtlasKey(atlasName);
    content += `  ${safeAtlasKey}: {\n`;
    for (const [frameName] of Object.entries(frames)) {
      const safeFrameKey = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(frameName) ? frameName : JSON.stringify(frameName);
      content += `    ${safeFrameKey}: "${frameName}",\n`;
    }
    content += `  },\n`;
  }

  content += `} as const;\n\n`;

  // Generate FramesData with position/size info
  content += `/** Frame position and size data */\n`;
  content += `export const FramesData = {\n`;

  for (const [atlasName, frames] of Object.entries(atlasData)) {
    const safeAtlasKey = sanitizeAtlasKey(atlasName);
    content += `  ${safeAtlasKey}: {\n`;
    for (const [frameName, frameData] of Object.entries(frames)) {
      const safeFrameKey = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(frameName) ? frameName : JSON.stringify(frameName);
      content += `    ${safeFrameKey}: { x: ${frameData.x}, y: ${frameData.y}, w: ${frameData.w}, h: ${frameData.h} },\n`;
    }
    content += `  },\n`;
  }

  content += `} as const;\n\n`;

  // Generate types for each atlas's textures
  content += `/** Texture types for each atlas */\n`;
  for (const [atlasName, frames] of Object.entries(atlasData)) {
    const sanitized = sanitizeAtlasKey(atlasName);
    const capitalizedTypeName = sanitized.charAt(0).toUpperCase() + sanitized.slice(1);

    content += `export type ${capitalizedTypeName}Textures = {\n`;
    content += `  textures: {\n`;
    for (const frameName of Object.keys(frames)) {
      const safeFrameKey = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(frameName) ? frameName : `"${frameName}"`;
      content += `    ${safeFrameKey}: any;\n`;
    }
    content += `  };\n`;
    content += `};\n\n`;
  }

  // Add helper types
  content += `export type AtlasName = keyof typeof FRAMES;\n`;
  content += `export type FrameName<T extends AtlasName> = keyof typeof FRAMES[T];\n`;

  return content;
}

/**
 * Recursively find all JSON files in a directory
 */
function findJsonFilesRecursive(
  dir: string,
  rootDir: string,
  fileList: { path: string; relativePath: string }[] = [],
): { path: string; relativePath: string }[] {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findJsonFilesRecursive(filePath, rootDir, fileList);
    } else if (file.endsWith('.json')) {
      const relativePath = path.relative(rootDir, filePath).split(path.sep).join('/');
      fileList.push({ path: filePath, relativePath });
    }
  }

  return fileList;
}

/**
 * Generate TypeScript definitions for all atlas JSON files in a single namespace
 */
export function generateAtlasTypes(assetsDir: string, outputDir: string): void {
  try {
    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Find all JSON files recursively
    const allJsonFiles = findJsonFilesRecursive(assetsDir, assetsDir);

    // Filter for atlas files (prefer .png.json, exclude manifest and resolution variants)
    const atlasFiles = allJsonFiles.filter(
      (file) =>
        file.relativePath.endsWith('.png.json') &&
        !file.relativePath.includes('assets-manifest') &&
        !file.relativePath.includes('@'),
    );

    const atlasData: AtlasFrameData = {};
    const processedBaseNames = new Set<string>();

    for (const file of atlasFiles) {
      const content = fs.readFileSync(file.path, 'utf-8');

      try {
        const jsonContent = JSON.parse(content);

        // Check if this is a texture atlas JSON (has frames and meta)
        if (!jsonContent.frames || !jsonContent.meta) {
          continue;
        }

        // Skip if there are no frames
        if (Object.keys(jsonContent.frames).length === 0) {
          continue;
        }

        // Extract the base name (remove extensions, keep path)
        // e.g., "ui/background-wololo.png.json" -> "ui/background-wolol"
        const baseNameWithPath = file.relativePath
          .replace(/\.(png|webp)\.json$/, '')
          .replace(/\.json$/, '')
          .slice(0, -7);

        // Sanitize for use as object key (convert slashes to underscores)
        const sanitizedKey = sanitizeAtlasKey(baseNameWithPath);

        // Skip if we already processed this sanitized key (collision check)
        if (processedBaseNames.has(sanitizedKey)) {
          console.warn(`Skipping duplicate atlas key: ${sanitizedKey} (from ${file.relativePath})`);
          continue;
        }
        processedBaseNames.add(sanitizedKey);

        // Extract frame data using sanitized key
        atlasData[sanitizedKey] = {};
        for (const [frameName, frameData] of Object.entries(jsonContent.frames)) {
          const frame = (frameData as any).frame;
          atlasData[sanitizedKey][frameName] = {
            x: frame.x,
            y: frame.y,
            w: frame.w,
            h: frame.h,
          };
        }
      } catch (error) {
        console.warn(`Failed to parse ${file.relativePath}:`, error);
      }
    }

    if (Object.keys(atlasData).length > 0) {
      // Generate single frames.ts file with all atlases
      const framesContent = generateFramesNamespace(atlasData);
      const framesPath = path.join(outputDir, 'frames.ts');
      fs.writeFileSync(framesPath, framesContent);
      console.log(`Generated frames.ts with ${Object.keys(atlasData).length} atlases`);

      // Generate index.ts file
      const indexContent = generateIndexFile();
      const indexPath = path.join(outputDir, 'index.ts');
      fs.writeFileSync(indexPath, indexContent);
      console.log('Generated index.ts');
    }
  } catch (error) {
    console.error('Failed to generate atlas types:', error);
  }
}

/**
 * Generate index.ts file that re-exports everything
 */
function generateIndexFile(): string {
  let content = `// Auto-generated index file for convenient imports\n`;
  content += `// This file re-exports all generated asset types\n`;
  content += `// Do not edit this file manually - it will be overwritten\n\n`;

  content += `export * from './manifest';\n`;
  content += `export * from './frames';\n`;
  content += `export * from './tiled';\n`;

  return content;
}
